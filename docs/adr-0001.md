# ADR-0001: Deterministic Matching Algorithm over LLM-based Ranking

## Status
Accepted

## Context
The Smart Offer Assistant needs to match client intake descriptions to relevant services from a trade catalogue. There are two main approaches:

1. **LLM-based ranking**: Use a large language model (GPT, Claude, etc.) to semantically understand the intake and rank services.

2. **Deterministic algorithm**: Use keyword matching, fuzzy search, and rule-based scoring with documented weights.

The requirements explicitly state: *"No blind AI: Do not use LLMs to rank; keep it explainable."*

## Decision
We will use a **deterministic matching algorithm** with the following components:

1. **Text normalization**: Lowercase, strip punctuation/diacritics, expand DEâ†’EN synonyms
2. **Keyword matching**: Direct token overlap between intake and catalogue items
3. **Fuzzy matching**: Fuse.js for approximate string matching
4. **Category boost**: Rule-based boost (e.g., scaffolding for difficult access)
5. **Weighted scoring**: `score = 0.4*keyword + 0.4*fuzzy + 0.2*boost`

## Consequences

### Positive
- **Explainable**: Every match can show exactly which keywords matched and why
- **Deterministic**: Same input always produces same output (testable, debuggable)
- **Fast**: No API calls, runs entirely client-side in milliseconds
- **Cost-effective**: No LLM API costs
- **Auditable**: Business can review and adjust weights/synonyms
- **Offline-capable**: Works without internet after initial load

### Negative
- **Limited semantic understanding**: Won't catch synonyms not in our dictionary
- **Maintenance burden**: Synonym list needs manual updates
- **No context awareness**: Can't understand complex multi-sentence descriptions as well as LLMs

### Mitigations
- Log unmatched queries to identify missing synonyms
- Consider hybrid approach in future: deterministic primary + embedding-based secondary signal
- Keep "why" explanations keyword-based even if embeddings are added

## Alternatives Considered

### Alternative 1: Full LLM Ranking
- **Pros**: Better semantic understanding, handles edge cases
- **Cons**: Not explainable ("black box"), expensive, slow, requires API availability
- **Rejected because**: Violates requirement for explainability

### Alternative 2: Embedding-based Similarity
- **Pros**: Better semantic matching than keywords, still deterministic
- **Cons**: Harder to explain "why" to users, requires embedding model
- **Deferred to**: Future enhancement (see proposal.md)

### Alternative 3: Elasticsearch/Lucene
- **Pros**: Battle-tested search, good fuzzy matching
- **Cons**: Requires server infrastructure, overkill for MVP
- **Rejected because**: Adds complexity without proportional benefit for demo

## References
- [Fuse.js Documentation](https://fusejs.io/)
- [Requirements PDF - Algorithm section](../SPF-Test-Smart-Offer-Assistent.pdf)
